// Code generated by the Lingua Franca compiler from:
// file://Users/yanghuang/Projects/cs267/benchmarks-lingua-franca/C/Savina/src/concurrency/Philosophers.lf
#define LOG_LEVEL 1
#define TARGET_FILES_DIRECTORY "/Users/yanghuang/Projects/cs267/benchmarks-lingua-franca/C/Savina/src-gen/concurrency/Philosophers"
#include "ctarget/ctarget.h"
#include "core/reactor.c"
#include "core/mixed_radix.h"
int main(int argc, char* argv[]) {
    return lf_reactor_c_main(argc, argv);
}
// =============== START reactor class Arbitrator
// *********** From the preamble, verbatim:
/*
 * Try to acquire both forks for a philosopher. Returns true if
 * successful and false otherwise. 
 */
bool acquire_forks(bool forks[], int instance, int num_philosophers) {
    int left = instance;
    int right = (instance + 1) % num_philosophers;
    if (forks[left] || forks[right]) {
        // someone else has access to the forks
        return false;
    } else {
        // Forks are available. Mark them in use.
        forks[left] = true;
        forks[right] = true;
        return true;
    }
}

/*
 * Release the forks acquired by a philosopher. This does not perform
 * any checks!
 */
 void free_forks(bool forks[], int instance, int num_philosophers) {
    forks[instance] = false; // left
    forks[(instance + 1) % num_philosophers] = false; // right
 }
 
 enum Reply {
    INVALID = 0,
    EAT = 1,
    DENIED = 2,
};
    

// *********** End of preamble.
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_start_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_finished_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_hungry_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_done_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_allFinished_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_eat_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} arbitrator_denied_t;
typedef struct {
    trigger_t* trigger;
    
    bool is_present;
    bool has_value;
    lf_token_t* token;
    
} arbitrator_send_replies_t;
typedef struct {
    struct self_base_t base;
    int num_philosophers;
    bool* forks;
    int* replies;
    int finished_philosophers;
    int arbitration_id;
    int retries;
    arbitrator_send_replies_t _lf_send_replies;
    arbitrator_start_t* _lf_start;
    // width of -2 indicates that it is not a multiport.
    int _lf_start_width;
    // Default input (in case it does not get connected)
    arbitrator_start_t _lf_default__start;
    // Multiport input array will be malloc'd later.
    arbitrator_finished_t** _lf_finished;
    int _lf_finished_width;
    // Default input (in case it does not get connected)
    arbitrator_finished_t _lf_default__finished;
    // Multiport input array will be malloc'd later.
    arbitrator_hungry_t** _lf_hungry;
    int _lf_hungry_width;
    // Default input (in case it does not get connected)
    arbitrator_hungry_t _lf_default__hungry;
    // Multiport input array will be malloc'd later.
    arbitrator_done_t** _lf_done;
    int _lf_done_width;
    // Default input (in case it does not get connected)
    arbitrator_done_t _lf_default__done;
    arbitrator_allFinished_t _lf_allFinished;
    int _lf_allFinished_width;
    // Array of output ports.
    arbitrator_eat_t* _lf_eat;
    int _lf_eat_width;
    // An array of pointers to the individual ports. Useful
    // for the lf_set macros to work out-of-the-box for
    // multiports in the body of reactions because their 
    // value can be accessed via a -> operator (e.g.,foo[i]->value).
    // So we have to handle multiports specially here a construct that
    // array of pointers.
    arbitrator_eat_t** _lf_eat_pointers;
    // Array of output ports.
    arbitrator_denied_t* _lf_denied;
    int _lf_denied_width;
    // An array of pointers to the individual ports. Useful
    // for the lf_set macros to work out-of-the-box for
    // multiports in the body of reactions because their 
    // value can be accessed via a -> operator (e.g.,foo[i]->value).
    // So we have to handle multiports specially here a construct that
    // array of pointers.
    arbitrator_denied_t** _lf_denied_pointers;
    reaction_t _lf__reaction_0;
    reaction_t _lf__reaction_1;
    reaction_t _lf__reaction_2;
    reaction_t _lf__reaction_3;
    reaction_t _lf__reaction_4;
    reaction_t _lf__reaction_5;
    trigger_t _lf__startup;
    reaction_t* _lf__startup_reactions[1];
    trigger_t _lf__send_replies;
    reaction_t* _lf__send_replies_reactions[1];
    trigger_t _lf__start;
    reaction_t* _lf__start_reactions[1];
    trigger_t _lf__finished;
    reaction_t* _lf__finished_reactions[1];
    trigger_t _lf__hungry;
    reaction_t* _lf__hungry_reactions[1];
    trigger_t _lf__done;
    reaction_t* _lf__done_reactions[1];
} arbitrator_self_t;
#include "ctarget/set.h"
void arbitratorreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    
    #pragma GCC diagnostic pop
    self->forks = calloc(self->num_philosophers, sizeof(bool));
    self->replies = calloc(self->num_philosophers, sizeof(int));
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void arbitratorreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    arbitrator_start_t* start = self->_lf_start;
    int start_width = self->_lf_start_width;
    #pragma GCC diagnostic pop
    self->finished_philosophers = 0;
    self->retries = 0;
    self->arbitration_id = 0;
    memset(self->replies, INVALID, sizeof(int) * self->num_philosophers);
    memset(self->forks, INVALID, sizeof(bool) * self->num_philosophers);
    
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void arbitratorreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    // Expose the action struct as a local variable whose name matches the action name.
    arbitrator_send_replies_t* send_replies = &self->_lf_send_replies;
    // Set the fields of the action struct to match the current trigger.
    send_replies->is_present = (bool)self->_lf__send_replies.status;
    send_replies->has_value = ((self->_lf__send_replies.token) != NULL && (self->_lf__send_replies.token)->value != NULL);
    send_replies->token = (self->_lf__send_replies.token);
    int eat_width = self->_lf_eat_width;
    arbitrator_eat_t** eat = self->_lf_eat_pointers;
    int denied_width = self->_lf_denied_width;
    arbitrator_denied_t** denied = self->_lf_denied_pointers;
    #pragma GCC diagnostic pop
    for(size_t i = 0; i < self->num_philosophers; i++) {
        if (self->replies[i] == EAT) {
            SET(eat[i], true);
        } else if (self->replies[i] == DENIED) {
            SET(denied[i], true);
        }
    }
    memset(self->replies, INVALID, sizeof(int) * self->num_philosophers);
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void arbitratorreaction_function_3(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    arbitrator_done_t** done = self->_lf_done;
    int done_width = self->_lf_done_width;
    #pragma GCC diagnostic pop
    for(int i = 0; i < done_width; i++) {
        if (done[i]->is_present) {
            free_forks(self->forks, i, self->num_philosophers);
        }
    }
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void arbitratorreaction_function_4(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    arbitrator_hungry_t** hungry = self->_lf_hungry;
    int hungry_width = self->_lf_hungry_width;
    arbitrator_send_replies_t* send_replies = &self->_lf_send_replies;
    #pragma GCC diagnostic pop
    // Iterate over all philosophers, each time starting from a different one.
    // This arbitration ensures that no philosopher has to starve.
    for(int i = self->arbitration_id; i < self->arbitration_id + self->num_philosophers; i++) {
        int j = i % self->num_philosophers;
        if (hungry[j]->is_present) {
            if (acquire_forks(self->forks, j, self->num_philosophers)) {
                self->replies[j] = EAT; 
            } else {
                self->replies[j] = DENIED;
                self->retries++;
            }    
        }
    }
    
    self->arbitration_id++;
    if (self->arbitration_id == self->num_philosophers) {
        self->arbitration_id = 0;
    }
    schedule(send_replies, 0);
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void arbitratorreaction_function_5(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    arbitrator_self_t* self = (arbitrator_self_t*)instance_args;
    arbitrator_finished_t** finished = self->_lf_finished;
    int finished_width = self->_lf_finished_width;
    arbitrator_allFinished_t* allFinished = &self->_lf_allFinished;
    #pragma GCC diagnostic pop
    for(int i = 0; i < finished_width; i++) {
        if (finished[i]->is_present) {
            self->finished_philosophers++;
            if (self->num_philosophers == self->finished_philosophers) {
                printf("Arbitrator: All philosophers are sated. Number of denials to philosophers: %d\n", self->retries);
                SET(allFinished, true);
            }
        }
    }
        
}
#include "ctarget/set_undef.h"
arbitrator_self_t* new_Arbitrator() {
    arbitrator_self_t* self = (arbitrator_self_t*)_lf_new_reactor(sizeof(arbitrator_self_t));
    self->_lf_send_replies.trigger = &self->_lf__send_replies;
    // Set input by default to an always absent default input.
    self->_lf_start = &self->_lf_default__start;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = arbitratorreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__reaction_1.number = 1;
    self->_lf__reaction_1.function = arbitratorreaction_function_1;
    self->_lf__reaction_1.self = self;
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    self->_lf__reaction_1.STP_handler = NULL;
    self->_lf__reaction_1.name = "?";
    self->_lf__reaction_1.mode = NULL;
    self->_lf__reaction_2.number = 2;
    self->_lf__reaction_2.function = arbitratorreaction_function_2;
    self->_lf__reaction_2.self = self;
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    self->_lf__reaction_2.STP_handler = NULL;
    self->_lf__reaction_2.name = "?";
    self->_lf__reaction_2.mode = NULL;
    self->_lf__reaction_3.number = 3;
    self->_lf__reaction_3.function = arbitratorreaction_function_3;
    self->_lf__reaction_3.self = self;
    self->_lf__reaction_3.deadline_violation_handler = NULL;
    self->_lf__reaction_3.STP_handler = NULL;
    self->_lf__reaction_3.name = "?";
    self->_lf__reaction_3.mode = NULL;
    self->_lf__reaction_4.number = 4;
    self->_lf__reaction_4.function = arbitratorreaction_function_4;
    self->_lf__reaction_4.self = self;
    self->_lf__reaction_4.deadline_violation_handler = NULL;
    self->_lf__reaction_4.STP_handler = NULL;
    self->_lf__reaction_4.name = "?";
    self->_lf__reaction_4.mode = NULL;
    self->_lf__reaction_5.number = 5;
    self->_lf__reaction_5.function = arbitratorreaction_function_5;
    self->_lf__reaction_5.self = self;
    self->_lf__reaction_5.deadline_violation_handler = NULL;
    self->_lf__reaction_5.STP_handler = NULL;
    self->_lf__reaction_5.name = "?";
    self->_lf__reaction_5.mode = NULL;
    self->_lf__startup_reactions[0] = &self->_lf__reaction_0;
    self->_lf__startup.last = NULL;
    self->_lf__startup.reactions = &self->_lf__startup_reactions[0];
    self->_lf__startup.number_of_reactions = 1;
    self->_lf__startup.is_timer = false;
    self->_lf__send_replies.last = NULL;
    self->_lf__send_replies_reactions[0] = &self->_lf__reaction_2;
    self->_lf__send_replies.reactions = &self->_lf__send_replies_reactions[0];
    self->_lf__send_replies.number_of_reactions = 1;
    self->_lf__send_replies.is_physical = false;
    
    self->_lf__send_replies.element_size = 0;
    self->_lf__start.last = NULL;
    self->_lf__start_reactions[0] = &self->_lf__reaction_1;
    self->_lf__start.reactions = &self->_lf__start_reactions[0];
    self->_lf__start.number_of_reactions = 1;
    self->_lf__start.element_size = sizeof(bool);
    self->_lf__finished.last = NULL;
    self->_lf__finished_reactions[0] = &self->_lf__reaction_5;
    self->_lf__finished.reactions = &self->_lf__finished_reactions[0];
    self->_lf__finished.number_of_reactions = 1;
    self->_lf__finished.element_size = sizeof(bool);
    self->_lf__hungry.last = NULL;
    self->_lf__hungry_reactions[0] = &self->_lf__reaction_4;
    self->_lf__hungry.reactions = &self->_lf__hungry_reactions[0];
    self->_lf__hungry.number_of_reactions = 1;
    self->_lf__hungry.element_size = sizeof(bool);
    self->_lf__done.last = NULL;
    self->_lf__done_reactions[0] = &self->_lf__reaction_3;
    self->_lf__done.reactions = &self->_lf__done_reactions[0];
    self->_lf__done.number_of_reactions = 1;
    self->_lf__done.element_size = sizeof(bool);
    return self;
}
// =============== END reactor class Arbitrator

// =============== START reactor class Philosopher
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_start_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_eat_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_denied_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_finished_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_hungry_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} philosopher_done_t;
typedef struct {
    struct self_base_t base;
    int bank_index;
    int count;
    int times_eaten;
    philosopher_start_t* _lf_start;
    // width of -2 indicates that it is not a multiport.
    int _lf_start_width;
    // Default input (in case it does not get connected)
    philosopher_start_t _lf_default__start;
    philosopher_eat_t* _lf_eat;
    // width of -2 indicates that it is not a multiport.
    int _lf_eat_width;
    // Default input (in case it does not get connected)
    philosopher_eat_t _lf_default__eat;
    philosopher_denied_t* _lf_denied;
    // width of -2 indicates that it is not a multiport.
    int _lf_denied_width;
    // Default input (in case it does not get connected)
    philosopher_denied_t _lf_default__denied;
    philosopher_finished_t _lf_finished;
    int _lf_finished_width;
    philosopher_hungry_t _lf_hungry;
    int _lf_hungry_width;
    philosopher_done_t _lf_done;
    int _lf_done_width;
    reaction_t _lf__reaction_0;
    reaction_t _lf__reaction_1;
    reaction_t _lf__reaction_2;
    trigger_t _lf__start;
    reaction_t* _lf__start_reactions[1];
    trigger_t _lf__eat;
    reaction_t* _lf__eat_reactions[1];
    trigger_t _lf__denied;
    reaction_t* _lf__denied_reactions[1];
} philosopher_self_t;
#include "ctarget/set.h"
void philosopherreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    philosopher_self_t* self = (philosopher_self_t*)instance_args;
    philosopher_start_t* start = self->_lf_start;
    int start_width = self->_lf_start_width;
    philosopher_hungry_t* hungry = &self->_lf_hungry;
    #pragma GCC diagnostic pop
    info_print("Hello! I am philosopher %d, and I am very hungry!", self->bank_index);
    self->times_eaten = 0;
    SET(hungry, true);
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void philosopherreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    philosopher_self_t* self = (philosopher_self_t*)instance_args;
    philosopher_eat_t* eat = self->_lf_eat;
    int eat_width = self->_lf_eat_width;
    philosopher_done_t* done = &self->_lf_done;
    philosopher_finished_t* finished = &self->_lf_finished;
    philosopher_hungry_t* hungry = &self->_lf_hungry;
    #pragma GCC diagnostic pop
    // ... take left and right fork
    info_print("Philosopher %d is eating.", self->bank_index);
    self->times_eaten++;
    SET(done, true);
    
    if (self->times_eaten == self->count) {
        SET(finished, true);
    } else {
        SET(hungry, true);
    }
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void philosopherreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    philosopher_self_t* self = (philosopher_self_t*)instance_args;
    philosopher_denied_t* denied = self->_lf_denied;
    int denied_width = self->_lf_denied_width;
    philosopher_hungry_t* hungry = &self->_lf_hungry;
    #pragma GCC diagnostic pop
    info_print("Philosopher %d was denied and is thinking.", self->bank_index);
    
    // Well, I will just try again...
    SET(hungry, true);
        
}
#include "ctarget/set_undef.h"
philosopher_self_t* new_Philosopher() {
    philosopher_self_t* self = (philosopher_self_t*)_lf_new_reactor(sizeof(philosopher_self_t));
    // Set input by default to an always absent default input.
    self->_lf_start = &self->_lf_default__start;
    // Set input by default to an always absent default input.
    self->_lf_eat = &self->_lf_default__eat;
    // Set input by default to an always absent default input.
    self->_lf_denied = &self->_lf_default__denied;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = philosopherreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__reaction_1.number = 1;
    self->_lf__reaction_1.function = philosopherreaction_function_1;
    self->_lf__reaction_1.self = self;
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    self->_lf__reaction_1.STP_handler = NULL;
    self->_lf__reaction_1.name = "?";
    self->_lf__reaction_1.mode = NULL;
    self->_lf__reaction_2.number = 2;
    self->_lf__reaction_2.function = philosopherreaction_function_2;
    self->_lf__reaction_2.self = self;
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    self->_lf__reaction_2.STP_handler = NULL;
    self->_lf__reaction_2.name = "?";
    self->_lf__reaction_2.mode = NULL;
    self->_lf__start.last = NULL;
    self->_lf__start_reactions[0] = &self->_lf__reaction_0;
    self->_lf__start.reactions = &self->_lf__start_reactions[0];
    self->_lf__start.number_of_reactions = 1;
    self->_lf__start.element_size = sizeof(bool);
    self->_lf__eat.last = NULL;
    self->_lf__eat_reactions[0] = &self->_lf__reaction_1;
    self->_lf__eat.reactions = &self->_lf__eat_reactions[0];
    self->_lf__eat.number_of_reactions = 1;
    self->_lf__eat.element_size = sizeof(bool);
    self->_lf__denied.last = NULL;
    self->_lf__denied_reactions[0] = &self->_lf__reaction_2;
    self->_lf__denied.reactions = &self->_lf__denied_reactions[0];
    self->_lf__denied.number_of_reactions = 1;
    self->_lf__denied.element_size = sizeof(bool);
    return self;
}
// =============== END reactor class Philosopher

// =============== START reactor class BenchmarkRunner
// *********** From the preamble, verbatim:
static double toMS(interval_t t) {
    return t / 1000000.0;
}

int comp (const void * elem1, const void * elem2) {
    int f = *((double*)elem1);
    int s = *((double*)elem2);
    if (f > s) return  1;
    if (f < s) return -1;
    return 0;
}

static double median(double* execTimes, int size) {
    if (size == 0) {
        return 0.0;
    }
    
    int middle = size / 2;
    if(size % 2 == 1) {
        return execTimes[middle];
    } else {
        return (execTimes[middle-1] + execTimes[middle]) / 2;
    }
}

static double* getMSMeasurements(interval_t* measured_times, int num_iterations) {
    
    double* msMeasurements = (double *) calloc(num_iterations, sizeof(double));
    for (int i = 0; i < num_iterations; i++) {
        msMeasurements[i] = toMS(measured_times[i]);
    }
    
    return msMeasurements;
}
    

// *********** End of preamble.
// *********** From the preamble, verbatim:
void printBenchmarkInfo(char* benchmarkId) {
    printf("Benchmark: %s\n", benchmarkId);
}

void printSystemInfo() {
    
    printf("System information\n"); 
    printf("O/S Name: ");
    
    #ifdef _WIN32
    printf("Windows 32-bit");
    #elif _WIN64
    printf("Windows 64-bit");
    #elif __APPLE__ || __MACH__
    printf("Mac OSX");
    #elif __linux__
    printf("Linux");
    #elif __FreeBSD__
    printf("FreeBSD");
    #elif __unix || __unix__
    printf("Unix");
    #else
    printf("Other");
    #endif
    
    printf("\n");
}
    

// *********** End of preamble.
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} benchmarkrunner_inStart_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} benchmarkrunner_finish_t;
typedef struct {
    bool value;
    bool is_present;
    int num_destinations;
    lf_token_t* token;
    int length;
    void (*destructor) (void* value);
    void* (*copy_constructor) (void* value);
} benchmarkrunner_start_t;
typedef struct {
    trigger_t* trigger;
    bool value;
    bool is_present;
    bool has_value;
    lf_token_t* token;
    
} benchmarkrunner_nextIteration_t;
typedef struct {
    trigger_t* trigger;
    bool value;
    bool is_present;
    bool has_value;
    lf_token_t* token;
    
} benchmarkrunner_done_t;
typedef struct {
    struct self_base_t base;
    int num_iterations;
    unsigned count;
    instant_t startTime;
    interval_t* measuredTimes;
    benchmarkrunner_nextIteration_t _lf_nextIteration;
    benchmarkrunner_done_t _lf_done;
    benchmarkrunner_inStart_t* _lf_inStart;
    // width of -2 indicates that it is not a multiport.
    int _lf_inStart_width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inStart_t _lf_default__inStart;
    benchmarkrunner_finish_t* _lf_finish;
    // width of -2 indicates that it is not a multiport.
    int _lf_finish_width;
    // Default input (in case it does not get connected)
    benchmarkrunner_finish_t _lf_default__finish;
    benchmarkrunner_start_t _lf_start;
    int _lf_start_width;
    reaction_t _lf__reaction_0;
    reaction_t _lf__reaction_1;
    reaction_t _lf__reaction_2;
    reaction_t _lf__reaction_3;
    trigger_t _lf__startup;
    reaction_t* _lf__startup_reactions[1];
    trigger_t _lf__nextIteration;
    reaction_t* _lf__nextIteration_reactions[1];
    trigger_t _lf__done;
    reaction_t* _lf__done_reactions[1];
    trigger_t _lf__inStart;
    trigger_t _lf__finish;
    reaction_t* _lf__finish_reactions[1];
} benchmarkrunner_self_t;
#include "ctarget/set.h"
void benchmarkrunnerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    benchmarkrunner_nextIteration_t* nextIteration = &self->_lf_nextIteration;
    #pragma GCC diagnostic pop
    // Initialize an array of interval_t
    self->measuredTimes = (interval_t *) calloc(self->num_iterations, sizeof(interval_t));
    schedule(nextIteration, 0);
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void benchmarkrunnerreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    // Expose the action struct as a local variable whose name matches the action name.
    benchmarkrunner_nextIteration_t* nextIteration = &self->_lf_nextIteration;
    // Set the fields of the action struct to match the current trigger.
    nextIteration->is_present = (bool)self->_lf__nextIteration.status;
    nextIteration->has_value = ((self->_lf__nextIteration.token) != NULL && (self->_lf__nextIteration.token)->value != NULL);
    nextIteration->token = (self->_lf__nextIteration.token);
    if (nextIteration->has_value) {
        nextIteration->value = *(bool*)(self->_lf__nextIteration.token)->value;
    }
    benchmarkrunner_start_t* start = &self->_lf_start;
    benchmarkrunner_done_t* done = &self->_lf_done;
    #pragma GCC diagnostic pop
    if (self->count < self->num_iterations) { 
        self->startTime = get_physical_time();
        SET(start, true);
    } else {
        schedule(done, 0);
    }
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void benchmarkrunnerreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    benchmarkrunner_finish_t* finish = self->_lf_finish;
    int finish_width = self->_lf_finish_width;
    benchmarkrunner_nextIteration_t* nextIteration = &self->_lf_nextIteration;
    #pragma GCC diagnostic pop
    interval_t end_time = get_physical_time();
    interval_t duration = end_time - self->startTime;
    self->measuredTimes[self->count] = duration;
    self->count += 1;
    
    printf("Iteration %d - %.3f ms\n", self->count, toMS(duration));
    
    schedule(nextIteration, 0);
    
        
}
#include "ctarget/set_undef.h"
#include "ctarget/set.h"
void benchmarkrunnerreaction_function_3(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    // Expose the action struct as a local variable whose name matches the action name.
    benchmarkrunner_done_t* done = &self->_lf_done;
    // Set the fields of the action struct to match the current trigger.
    done->is_present = (bool)self->_lf__done.status;
    done->has_value = ((self->_lf__done.token) != NULL && (self->_lf__done.token)->value != NULL);
    done->token = (self->_lf__done.token);
    if (done->has_value) {
        done->value = *(bool*)(self->_lf__done.token)->value;
    }
    #pragma GCC diagnostic pop
    double* measuredMSTimes = getMSMeasurements(self->measuredTimes, self->num_iterations);
    qsort(measuredMSTimes, self->num_iterations, sizeof(double), comp);
    
    printf("Execution - Summary:\n");
    printf("Best Time:\t %.3f msec\n", measuredMSTimes[0]);
    printf("Worst Time:\t %.3f msec\n", measuredMSTimes[self->num_iterations - 1]);
    printf("Median Time:\t %.3f msec\n", median(measuredMSTimes, self->num_iterations));
    request_stop();
        
}
#include "ctarget/set_undef.h"
benchmarkrunner_self_t* new_BenchmarkRunner() {
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)_lf_new_reactor(sizeof(benchmarkrunner_self_t));
    self->_lf_nextIteration.trigger = &self->_lf__nextIteration;
    self->_lf_done.trigger = &self->_lf__done;
    // Set input by default to an always absent default input.
    self->_lf_inStart = &self->_lf_default__inStart;
    // Set input by default to an always absent default input.
    self->_lf_finish = &self->_lf_default__finish;
    self->_lf__reaction_0.number = 0;
    self->_lf__reaction_0.function = benchmarkrunnerreaction_function_0;
    self->_lf__reaction_0.self = self;
    self->_lf__reaction_0.deadline_violation_handler = NULL;
    self->_lf__reaction_0.STP_handler = NULL;
    self->_lf__reaction_0.name = "?";
    self->_lf__reaction_0.mode = NULL;
    self->_lf__reaction_1.number = 1;
    self->_lf__reaction_1.function = benchmarkrunnerreaction_function_1;
    self->_lf__reaction_1.self = self;
    self->_lf__reaction_1.deadline_violation_handler = NULL;
    self->_lf__reaction_1.STP_handler = NULL;
    self->_lf__reaction_1.name = "?";
    self->_lf__reaction_1.mode = NULL;
    self->_lf__reaction_2.number = 2;
    self->_lf__reaction_2.function = benchmarkrunnerreaction_function_2;
    self->_lf__reaction_2.self = self;
    self->_lf__reaction_2.deadline_violation_handler = NULL;
    self->_lf__reaction_2.STP_handler = NULL;
    self->_lf__reaction_2.name = "?";
    self->_lf__reaction_2.mode = NULL;
    self->_lf__reaction_3.number = 3;
    self->_lf__reaction_3.function = benchmarkrunnerreaction_function_3;
    self->_lf__reaction_3.self = self;
    self->_lf__reaction_3.deadline_violation_handler = NULL;
    self->_lf__reaction_3.STP_handler = NULL;
    self->_lf__reaction_3.name = "?";
    self->_lf__reaction_3.mode = NULL;
    self->_lf__startup_reactions[0] = &self->_lf__reaction_0;
    self->_lf__startup.last = NULL;
    self->_lf__startup.reactions = &self->_lf__startup_reactions[0];
    self->_lf__startup.number_of_reactions = 1;
    self->_lf__startup.is_timer = false;
    self->_lf__nextIteration.last = NULL;
    self->_lf__nextIteration_reactions[0] = &self->_lf__reaction_1;
    self->_lf__nextIteration.reactions = &self->_lf__nextIteration_reactions[0];
    self->_lf__nextIteration.number_of_reactions = 1;
    self->_lf__nextIteration.is_physical = false;
    
    self->_lf__nextIteration.element_size = sizeof(bool);
    self->_lf__done.last = NULL;
    self->_lf__done_reactions[0] = &self->_lf__reaction_3;
    self->_lf__done.reactions = &self->_lf__done_reactions[0];
    self->_lf__done.number_of_reactions = 1;
    self->_lf__done.is_physical = false;
    
    self->_lf__done.element_size = sizeof(bool);
    self->_lf__inStart.last = NULL;
    self->_lf__inStart.element_size = sizeof(bool);
    self->_lf__finish.last = NULL;
    self->_lf__finish_reactions[0] = &self->_lf__reaction_2;
    self->_lf__finish.reactions = &self->_lf__finish_reactions[0];
    self->_lf__finish.number_of_reactions = 1;
    self->_lf__finish.element_size = sizeof(bool);
    return self;
}
// =============== END reactor class BenchmarkRunner

// =============== START reactor class Philosophers
typedef struct {
    struct self_base_t base;
    int numIterations;
    int num_philosophers;
    int count;
} philosophers_self_t;
philosophers_self_t* new_Philosophers() {
    philosophers_self_t* self = (philosophers_self_t*)_lf_new_reactor(sizeof(philosophers_self_t));
    
    return self;
}
// =============== END reactor class Philosophers

char* _lf_default_argv[] = { "Philosophers", "-f", "true" };
void _lf_set_default_command_line_options() {
        default_argc = 3;
        default_argv = _lf_default_argv;
}
// Array of pointers to timer triggers to be scheduled in _lf_initialize_timers().
trigger_t** _lf_timer_triggers = NULL;
int _lf_timer_triggers_size = 0;
// Array of pointers to shutdown triggers.
reaction_t** _lf_shutdown_reactions = NULL;
int _lf_shutdown_reactions_size = 0;
trigger_t* _lf_action_for_port(int port_id) {
        return NULL;
}
void _lf_initialize_trigger_objects() {
    // Initialize the _lf_clock
    lf_initialize_clock();
    _lf_tokens_with_ref_count_size = 3;
    _lf_tokens_with_ref_count = (token_present_t*)calloc(3, sizeof(token_present_t));
    if (_lf_tokens_with_ref_count == NULL) lf_print_error_and_exit("Out of memory!");
    // Create the array that will contain pointers to is_present fields to reset on each step.
    _lf_is_present_fields_size = 105;
    _lf_is_present_fields = (bool**)calloc(105, sizeof(bool*));
    if (_lf_is_present_fields == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated = (bool**)calloc(105, sizeof(bool*));
    if (_lf_is_present_fields_abbreviated == NULL) lf_print_error_and_exit("Out of memory!");
    _lf_is_present_fields_abbreviated_size = 0;
    
    _lf_startup_reactions = (reaction_t**)calloc(2, sizeof(reaction_t*));
    _lf_startup_reactions_size = 2;
    int _lf_startup_reactions_count = 0;
    int _lf_shutdown_reactions_count = 0;
    int _lf_timer_triggers_count = 0;
    int _lf_tokens_with_ref_count_count = 0;
    philosophers_self_t* philosophers_self[1];
    arbitrator_self_t* philosophers_arbitrator_self[1];
    philosopher_self_t* philosophers_philosophers_self[20];
    benchmarkrunner_self_t* philosophers_runner_self[1];
    // ***** Start initializing Philosophers of class Philosophers
    philosophers_self[0] = new_Philosophers();
    int bank_index = 0;
    philosophers_self[0]->numIterations = 12;
    philosophers_self[0]->num_philosophers = 20;
    philosophers_self[0]->count = 10000;
    
    {
        // ***** Start initializing Philosophers.arbitrator of class Arbitrator
        philosophers_arbitrator_self[0] = new_Arbitrator();
        int bank_index = 0;
        philosophers_arbitrator_self[0]->num_philosophers = philosophers_self[0]->num_philosophers;
        // width of -2 indicates that it is not a multiport.
        philosophers_arbitrator_self[0]->_lf_allFinished_width = -2;
        philosophers_arbitrator_self[0]->_lf_eat_width = 20;
        // Allocate memory for multiport output.
        philosophers_arbitrator_self[0]->_lf_eat = (arbitrator_eat_t*)_lf_allocate(
                20, sizeof(arbitrator_eat_t),
                &philosophers_arbitrator_self[0]->base.allocations); 
        philosophers_arbitrator_self[0]->_lf_eat_pointers = (arbitrator_eat_t**)_lf_allocate(
                20, sizeof(arbitrator_eat_t*),
                &philosophers_arbitrator_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 20; i++) {
                philosophers_arbitrator_self[0]->_lf_eat_pointers[i] = &(philosophers_arbitrator_self[0]->_lf_eat[i]);
        }
        philosophers_arbitrator_self[0]->_lf_denied_width = 20;
        // Allocate memory for multiport output.
        philosophers_arbitrator_self[0]->_lf_denied = (arbitrator_denied_t*)_lf_allocate(
                20, sizeof(arbitrator_denied_t),
                &philosophers_arbitrator_self[0]->base.allocations); 
        philosophers_arbitrator_self[0]->_lf_denied_pointers = (arbitrator_denied_t**)_lf_allocate(
                20, sizeof(arbitrator_denied_t*),
                &philosophers_arbitrator_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 20; i++) {
                philosophers_arbitrator_self[0]->_lf_denied_pointers[i] = &(philosophers_arbitrator_self[0]->_lf_denied[i]);
        }
        // width of -2 indicates that it is not a multiport.
        philosophers_arbitrator_self[0]->_lf_start_width = -2;
        philosophers_arbitrator_self[0]->_lf_finished_width = 20;
        // Allocate memory for multiport inputs.
        philosophers_arbitrator_self[0]->_lf_finished = (arbitrator_finished_t**)_lf_allocate(
                20, sizeof(arbitrator_finished_t*),
                &philosophers_arbitrator_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 20; i++) {
            philosophers_arbitrator_self[0]->_lf_finished[i] = &philosophers_arbitrator_self[0]->_lf_default__finished;
        }
        philosophers_arbitrator_self[0]->_lf_hungry_width = 20;
        // Allocate memory for multiport inputs.
        philosophers_arbitrator_self[0]->_lf_hungry = (arbitrator_hungry_t**)_lf_allocate(
                20, sizeof(arbitrator_hungry_t*),
                &philosophers_arbitrator_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 20; i++) {
            philosophers_arbitrator_self[0]->_lf_hungry[i] = &philosophers_arbitrator_self[0]->_lf_default__hungry;
        }
        philosophers_arbitrator_self[0]->_lf_done_width = 20;
        // Allocate memory for multiport inputs.
        philosophers_arbitrator_self[0]->_lf_done = (arbitrator_done_t**)_lf_allocate(
                20, sizeof(arbitrator_done_t*),
                &philosophers_arbitrator_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 20; i++) {
            philosophers_arbitrator_self[0]->_lf_done[i] = &philosophers_arbitrator_self[0]->_lf_default__done;
        }
        _lf_startup_reactions[_lf_startup_reactions_count++] = &philosophers_arbitrator_self[0]->_lf__reaction_0;
        { // For scoping
            static int _initial = 0;
            philosophers_arbitrator_self[0]->finished_philosophers = _initial;
        } // End scoping.
        { // For scoping
            static int _initial = 0;
            philosophers_arbitrator_self[0]->arbitration_id = _initial;
        } // End scoping.
        { // For scoping
            static int _initial = 0;
            philosophers_arbitrator_self[0]->retries = _initial;
        } // End scoping.
        // Initializing action Philosophers.arbitrator.send_replies
        philosophers_arbitrator_self[0]->_lf__send_replies.offset = 0;
        philosophers_arbitrator_self[0]->_lf__send_replies.period = -1;
        philosophers_arbitrator_self[0]->_lf__send_replies.mode = NULL;
        philosophers_arbitrator_self[0]->_lf__send_replies.token = _lf_create_token(0);
        philosophers_arbitrator_self[0]->_lf__send_replies.status = absent;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].token = &philosophers_arbitrator_self[0]->_lf__send_replies.token;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].status = &philosophers_arbitrator_self[0]->_lf__send_replies.status;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count++].reset_is_present = true;
        //***** End initializing Philosophers.arbitrator
    }
    // Reactor is a bank. Iterate over bank members.
    for (int philosophers_philosophers_i = 0; philosophers_philosophers_i < 20; philosophers_philosophers_i++) {
        // ***** Start initializing Philosophers.philosophers of class Philosopher
        philosophers_philosophers_self[philosophers_philosophers_i] = new_Philosopher();
        int bank_index = philosophers_philosophers_i;
        philosophers_philosophers_self[philosophers_philosophers_i]->bank_index = philosophers_philosophers_i;
        philosophers_philosophers_self[philosophers_philosophers_i]->count = philosophers_self[0]->count;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_finished_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_hungry_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_done_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_start_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_eat_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_philosophers_self[philosophers_philosophers_i]->_lf_denied_width = -2;
        
        //***** End initializing Philosophers.philosophers
    }
    {
        // ***** Start initializing Philosophers.runner of class BenchmarkRunner
        philosophers_runner_self[0] = new_BenchmarkRunner();
        int bank_index = 0;
        philosophers_runner_self[0]->num_iterations = philosophers_self[0]->numIterations;
        // width of -2 indicates that it is not a multiport.
        philosophers_runner_self[0]->_lf_start_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_runner_self[0]->_lf_inStart_width = -2;
        // width of -2 indicates that it is not a multiport.
        philosophers_runner_self[0]->_lf_finish_width = -2;
        _lf_startup_reactions[_lf_startup_reactions_count++] = &philosophers_runner_self[0]->_lf__reaction_0;
        { // For scoping
            static unsigned _initial = 0;
            philosophers_runner_self[0]->count = _initial;
        } // End scoping.
        // Initializing action Philosophers.runner.nextIteration
        philosophers_runner_self[0]->_lf__nextIteration.offset = 0;
        philosophers_runner_self[0]->_lf__nextIteration.period = -1;
        philosophers_runner_self[0]->_lf__nextIteration.mode = NULL;
        // Initializing action Philosophers.runner.done
        philosophers_runner_self[0]->_lf__done.offset = 0;
        philosophers_runner_self[0]->_lf__done.period = -1;
        philosophers_runner_self[0]->_lf__done.mode = NULL;
        philosophers_runner_self[0]->_lf__nextIteration.token = _lf_create_token(sizeof(bool));
        philosophers_runner_self[0]->_lf__nextIteration.status = absent;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].token = &philosophers_runner_self[0]->_lf__nextIteration.token;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].status = &philosophers_runner_self[0]->_lf__nextIteration.status;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count++].reset_is_present = true;
        philosophers_runner_self[0]->_lf__done.token = _lf_create_token(sizeof(bool));
        philosophers_runner_self[0]->_lf__done.status = absent;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].token = &philosophers_runner_self[0]->_lf__done.token;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count].status = &philosophers_runner_self[0]->_lf__done.status;
        _lf_tokens_with_ref_count[_lf_tokens_with_ref_count_count++].reset_is_present = true;
        //***** End initializing Philosophers.runner
    }
    //***** End initializing Philosophers
    
    // **** Start deferred initialize for Philosophers
    {
        
        
        
        // **** Start deferred initialize for Philosophers.arbitrator
        {
            
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 0 of Philosophers.arbitrator
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 1 of Philosophers.arbitrator
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_2.num_outputs = 40;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_arbitrator_self[0]->_lf__reaction_2.triggers = (trigger_t***)_lf_allocate(
                    40, sizeof(trigger_t**),
                    &philosophers_arbitrator_self[0]->base.allocations);
            philosophers_arbitrator_self[0]->_lf__reaction_2.triggered_sizes = (int*)_lf_allocate(
                    40, sizeof(int),
                    &philosophers_arbitrator_self[0]->base.allocations);
            philosophers_arbitrator_self[0]->_lf__reaction_2.output_produced = (bool**)_lf_allocate(
                    40, sizeof(bool*),
                    &philosophers_arbitrator_self[0]->base.allocations);
            {
                int count = 0;
                {
                    for (int i = 0; i < 20; i++) {
                        philosophers_arbitrator_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &philosophers_arbitrator_self[0]->_lf_eat[i].is_present;
                    }
                    count += 20;
                }
                {
                    for (int i = 0; i < 20; i++) {
                        philosophers_arbitrator_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &philosophers_arbitrator_self[0]->_lf_denied[i].is_present;
                    }
                    count += 20;
                }
            }
            
            // ** End initialization for reaction 2 of Philosophers.arbitrator
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_3.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 3 of Philosophers.arbitrator
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_4 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_4.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 4 of Philosophers.arbitrator
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_5 of Philosophers.arbitrator.
            philosophers_arbitrator_self[0]->_lf__reaction_5.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_arbitrator_self[0]->_lf__reaction_5.triggers = (trigger_t***)_lf_allocate(
                    1, sizeof(trigger_t**),
                    &philosophers_arbitrator_self[0]->base.allocations);
            philosophers_arbitrator_self[0]->_lf__reaction_5.triggered_sizes = (int*)_lf_allocate(
                    1, sizeof(int),
                    &philosophers_arbitrator_self[0]->base.allocations);
            philosophers_arbitrator_self[0]->_lf__reaction_5.output_produced = (bool**)_lf_allocate(
                    1, sizeof(bool*),
                    &philosophers_arbitrator_self[0]->base.allocations);
            {
                int count = 0;
                {
                    philosophers_arbitrator_self[0]->_lf__reaction_5.output_produced[count++] = &philosophers_arbitrator_self[0]->_lf_allFinished.is_present;
                }
            }
            
            // ** End initialization for reaction 5 of Philosophers.arbitrator
            
        }
        // **** End of deferred initialize for Philosophers.arbitrator
        // **** Start deferred initialize for Philosophers.philosophers
        // Reactor is a bank. Iterate over bank members.
        for (int philosophers_philosophers_i = 0; philosophers_philosophers_i < 20; philosophers_philosophers_i++) {
            
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of Philosophers.philosophers.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.triggers = (trigger_t***)_lf_allocate(
                    1, sizeof(trigger_t**),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.triggered_sizes = (int*)_lf_allocate(
                    1, sizeof(int),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.output_produced = (bool**)_lf_allocate(
                    1, sizeof(bool*),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            {
                int count = 0;
                {
                    philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.output_produced[count++] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_hungry.is_present;
                }
            }
            
            // ** End initialization for reaction 0 of Philosophers.philosophers
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Philosophers.philosophers.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.num_outputs = 3;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.triggers = (trigger_t***)_lf_allocate(
                    3, sizeof(trigger_t**),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.triggered_sizes = (int*)_lf_allocate(
                    3, sizeof(int),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.output_produced = (bool**)_lf_allocate(
                    3, sizeof(bool*),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            {
                int count = 0;
                {
                    philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.output_produced[count++] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_done.is_present;
                }
                {
                    philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.output_produced[count++] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_finished.is_present;
                }
                {
                    philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.output_produced[count++] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_hungry.is_present;
                }
            }
            
            // ** End initialization for reaction 1 of Philosophers.philosophers
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Philosophers.philosophers.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.triggers = (trigger_t***)_lf_allocate(
                    1, sizeof(trigger_t**),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.triggered_sizes = (int*)_lf_allocate(
                    1, sizeof(int),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.output_produced = (bool**)_lf_allocate(
                    1, sizeof(bool*),
                    &philosophers_philosophers_self[philosophers_philosophers_i]->base.allocations);
            {
                int count = 0;
                {
                    philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.output_produced[count++] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_hungry.is_present;
                }
            }
            
            // ** End initialization for reaction 2 of Philosophers.philosophers
            
        }
        // **** End of deferred initialize for Philosophers.philosophers
        // **** Start deferred initialize for Philosophers.runner
        {
            
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_0 of Philosophers.runner.
            philosophers_runner_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 0 of Philosophers.runner
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Philosophers.runner.
            philosophers_runner_self[0]->_lf__reaction_1.num_outputs = 1;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            philosophers_runner_self[0]->_lf__reaction_1.triggers = (trigger_t***)_lf_allocate(
                    1, sizeof(trigger_t**),
                    &philosophers_runner_self[0]->base.allocations);
            philosophers_runner_self[0]->_lf__reaction_1.triggered_sizes = (int*)_lf_allocate(
                    1, sizeof(int),
                    &philosophers_runner_self[0]->base.allocations);
            philosophers_runner_self[0]->_lf__reaction_1.output_produced = (bool**)_lf_allocate(
                    1, sizeof(bool*),
                    &philosophers_runner_self[0]->base.allocations);
            {
                int count = 0;
                {
                    philosophers_runner_self[0]->_lf__reaction_1.output_produced[count++] = &philosophers_runner_self[0]->_lf_start.is_present;
                }
            }
            
            // ** End initialization for reaction 1 of Philosophers.runner
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Philosophers.runner.
            philosophers_runner_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 2 of Philosophers.runner
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Philosophers.runner.
            philosophers_runner_self[0]->_lf__reaction_3.num_outputs = 0;
            {
                int count = 0;
            }
            
            // ** End initialization for reaction 3 of Philosophers.runner
            
        }
        // **** End of deferred initialize for Philosophers.runner
    }
    // **** End of deferred initialize for Philosophers
    // **** Start non-nested deferred initialize for Philosophers
    
    
    
    // **** Start non-nested deferred initialize for Philosophers.arbitrator
    
    // For reference counting, set num_destinations for port Philosophers.arbitrator.allFinished.
    // Iterate over range Philosophers.arbitrator.allFinished(0,1)->[Philosophers.runner.finish(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        philosophers_arbitrator_self[src_runtime]->_lf_allFinished.num_destinations = 1;
    }
    // For reference counting, set num_destinations for port Philosophers.arbitrator.eat.
    // Iterate over range Philosophers.arbitrator.eat(0,20)->[Philosophers.philosophers.eat(0,20)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 20, 1 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 20; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            philosophers_arbitrator_self[src_runtime]->_lf_eat[src_channel].num_destinations = 20;
            mixed_radix_incr(&range_mr);
        }
    }
    // For reference counting, set num_destinations for port Philosophers.arbitrator.denied.
    // Iterate over range Philosophers.arbitrator.denied(0,20)->[Philosophers.philosophers.denied(0,20)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 20, 1 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 20; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            philosophers_arbitrator_self[src_runtime]->_lf_denied[src_channel].num_destinations = 20;
            mixed_radix_incr(&range_mr);
        }
    }
    {
        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.arbitrator.eat(0,20)->[Philosophers.philosophers.eat(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 20, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 2 of Philosophers.arbitrator triggers 1 downstream reactions
                // through port Philosophers.arbitrator.eat.
                philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 2 of Philosophers.arbitrator, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.arbitrator.eat
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_arbitrator_self[src_runtime]->base.allocations); 
                philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        // Iterate over range Philosophers.arbitrator.denied(0,20)->[Philosophers.philosophers.denied(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 20, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 2 of Philosophers.arbitrator triggers 1 downstream reactions
                // through port Philosophers.arbitrator.denied.
                philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 2 of Philosophers.arbitrator, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.arbitrator.denied
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_arbitrator_self[src_runtime]->base.allocations); 
                philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.arbitrator.eat(0,20)->[Philosophers.philosophers.eat(0,20)] and Philosophers.philosophers.eat(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 20, 1 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.philosophers.eat(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 1, 20 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.philosophers.eat's trigger struct.
                    philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_philosophers_self[dst_runtime]->_lf__eat;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 20;
        // Iterate over ranges Philosophers.arbitrator.denied(0,20)->[Philosophers.philosophers.denied(0,20)] and Philosophers.philosophers.denied(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 20, 1 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.philosophers.denied(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 1, 20 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.philosophers.denied's trigger struct.
                    philosophers_arbitrator_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_philosophers_self[dst_runtime]->_lf__denied;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    {
        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.arbitrator.allFinished(0,1)->[Philosophers.runner.finish(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 5 of Philosophers.arbitrator triggers 1 downstream reactions
            // through port Philosophers.arbitrator.allFinished.
            philosophers_arbitrator_self[src_runtime]->_lf__reaction_5.triggered_sizes[triggers_index[src_runtime]] = 1;
            // For reaction 5 of Philosophers.arbitrator, allocate an
            // array of trigger pointers for downstream reactions through port Philosophers.arbitrator.allFinished
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    1, sizeof(trigger_t*),
                    &philosophers_arbitrator_self[src_runtime]->base.allocations); 
            philosophers_arbitrator_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.arbitrator.allFinished(0,1)->[Philosophers.runner.finish(0,1)] and Philosophers.runner.finish(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.runner.finish(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.runner.finish's trigger struct.
                philosophers_arbitrator_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_runner_self[dst_runtime]->_lf__finish;
            }
        }
    }
    
    // **** End of non-nested deferred initialize for Philosophers.arbitrator
    // **** Start non-nested deferred initialize for Philosophers.philosophers
    
    // For reference counting, set num_destinations for port Philosophers.philosophers.finished.
    // Iterate over range Philosophers.philosophers.finished(0,20)->[Philosophers.arbitrator.finished(0,20)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 1, 20 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 20; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            philosophers_philosophers_self[src_runtime]->_lf_finished.num_destinations = 1;
            mixed_radix_incr(&range_mr);
        }
    }
    // For reference counting, set num_destinations for port Philosophers.philosophers.hungry.
    // Iterate over range Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 1, 20 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 20; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            philosophers_philosophers_self[src_runtime]->_lf_hungry.num_destinations = 1;
            mixed_radix_incr(&range_mr);
        }
    }
    // For reference counting, set num_destinations for port Philosophers.philosophers.done.
    // Iterate over range Philosophers.philosophers.done(0,20)->[Philosophers.arbitrator.done(0,20)].
    {
        int range_start[] =  { 0, 0 };
        int range_radixes[] = { 1, 20 };
        int permutation[] = { 0, 1 };
        mixed_radix_int_t range_mr = {
            2,
            range_start,
            range_radixes,
            permutation
        };
        for (int range_count = 0; range_count < 0 + 20; range_count++) {
            int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
            int src_channel = range_mr.digits[0]; // Channel index.
            int src_bank = range_mr.digits[1]; // Bank index.
            philosophers_philosophers_self[src_runtime]->_lf_done.num_destinations = 1;
            mixed_radix_incr(&range_mr);
        }
    }
    {
        int triggers_index[20] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 0 of Philosophers.philosophers triggers 1 downstream reactions
                // through port Philosophers.philosophers.hungry.
                philosophers_philosophers_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 0 of Philosophers.philosophers, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.philosophers.hungry
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_philosophers_self[src_runtime]->base.allocations); 
                philosophers_philosophers_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 20; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)] and Philosophers.arbitrator.hungry(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 1, 20 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.arbitrator.hungry(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 20, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.arbitrator.hungry's trigger struct.
                    philosophers_philosophers_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__hungry;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    {
        int triggers_index[20] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.philosophers.done(0,20)->[Philosophers.arbitrator.done(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 1 of Philosophers.philosophers triggers 1 downstream reactions
                // through port Philosophers.philosophers.done.
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Philosophers.philosophers, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.philosophers.done
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_philosophers_self[src_runtime]->base.allocations); 
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        // Iterate over range Philosophers.philosophers.finished(0,20)->[Philosophers.arbitrator.finished(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 1 of Philosophers.philosophers triggers 1 downstream reactions
                // through port Philosophers.philosophers.finished.
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Philosophers.philosophers, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.philosophers.finished
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_philosophers_self[src_runtime]->base.allocations); 
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        // Iterate over range Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 1 of Philosophers.philosophers triggers 1 downstream reactions
                // through port Philosophers.philosophers.hungry.
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Philosophers.philosophers, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.philosophers.hungry
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_philosophers_self[src_runtime]->base.allocations); 
                philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 20; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.philosophers.done(0,20)->[Philosophers.arbitrator.done(0,20)] and Philosophers.arbitrator.done(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 1, 20 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.arbitrator.done(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 20, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.arbitrator.done's trigger struct.
                    philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__done;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
        for (int i = 0; i < 20; i++) triggers_index[i] = 1;
        // Iterate over ranges Philosophers.philosophers.finished(0,20)->[Philosophers.arbitrator.finished(0,20)] and Philosophers.arbitrator.finished(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 1, 20 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.arbitrator.finished(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 20, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.arbitrator.finished's trigger struct.
                    philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__finished;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
        for (int i = 0; i < 20; i++) triggers_index[i] = 2;
        // Iterate over ranges Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)] and Philosophers.arbitrator.hungry(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 1, 20 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.arbitrator.hungry(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 20, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.arbitrator.hungry's trigger struct.
                    philosophers_philosophers_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__hungry;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    {
        int triggers_index[20] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int src_channel = range_mr.digits[0]; // Channel index.
                int src_bank = range_mr.digits[1]; // Bank index.
                // Reaction 2 of Philosophers.philosophers triggers 1 downstream reactions
                // through port Philosophers.philosophers.hungry.
                philosophers_philosophers_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 2 of Philosophers.philosophers, allocate an
                // array of trigger pointers for downstream reactions through port Philosophers.philosophers.hungry
                trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                        1, sizeof(trigger_t*),
                        &philosophers_philosophers_self[src_runtime]->base.allocations); 
                philosophers_philosophers_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                mixed_radix_incr(&range_mr);
            }
        }
        for (int i = 0; i < 20; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)] and Philosophers.arbitrator.hungry(0,20).
        {
            int src_start[] =  { 0, 0 };
            int src_value[] =  { 0, 0 }; // Will be incremented.
            int src_radixes[] = { 1, 20 };
            int src_permutation[] = { 0, 1 };
            mixed_radix_int_t src_range_mr = {
                2,
                src_value,
                src_radixes,
                src_permutation
            };
            // Iterate over range Philosophers.arbitrator.hungry(0,20).
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 20, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 20; range_count++) {
                    int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    int dst_channel = range_mr.digits[0]; // Channel index.
                    int dst_bank = range_mr.digits[1]; // Bank index.
                    int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                    int src_channel = src_range_mr.digits[0]; // Channel index.
                    int src_bank = src_range_mr.digits[1]; // Bank index.
                    // Point to destination port Philosophers.arbitrator.hungry's trigger struct.
                    philosophers_philosophers_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__hungry;
                    mixed_radix_incr(&src_range_mr);
                    if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                        // Start over with the source.
                        for (int i = 0; i < src_range_mr.size; i++) {
                            src_range_mr.digits[i] = src_start[i];
                        }
                    }
                    mixed_radix_incr(&range_mr);
                }
            }
        }
    }
    
    // **** End of non-nested deferred initialize for Philosophers.philosophers
    // **** Start non-nested deferred initialize for Philosophers.runner
    
    // For reference counting, set num_destinations for port Philosophers.runner.start.
    // Iterate over range Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)].
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        int range_count = 0;
        philosophers_runner_self[src_runtime]->_lf_start.num_destinations = 21;
    }
    {
        int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
        // Iterate over range Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)].
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            int range_count = 0;
            // Reaction 1 of Philosophers.runner triggers 21 downstream reactions
            // through port Philosophers.runner.start.
            philosophers_runner_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 21;
            // For reaction 1 of Philosophers.runner, allocate an
            // array of trigger pointers for downstream reactions through port Philosophers.runner.start
            trigger_t** trigger_array = (trigger_t**)_lf_allocate(
                    21, sizeof(trigger_t*),
                    &philosophers_runner_self[src_runtime]->base.allocations); 
            philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
        }
        for (int i = 0; i < 1; i++) triggers_index[i] = 0;
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.arbitrator.start(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.arbitrator.start(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.arbitrator.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &philosophers_arbitrator_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(19,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(19,1).
            {
                int dst_runtime = 19; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 19; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][1] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(18,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(18,1).
            {
                int dst_runtime = 18; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 18; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][2] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(17,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(17,1).
            {
                int dst_runtime = 17; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 17; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][3] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(16,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(16,1).
            {
                int dst_runtime = 16; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 16; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][4] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(15,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(15,1).
            {
                int dst_runtime = 15; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 15; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][5] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(14,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(14,1).
            {
                int dst_runtime = 14; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 14; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][6] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(13,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(13,1).
            {
                int dst_runtime = 13; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 13; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][7] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(12,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(12,1).
            {
                int dst_runtime = 12; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 12; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][8] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(11,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(11,1).
            {
                int dst_runtime = 11; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 11; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][9] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(10,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(10,1).
            {
                int dst_runtime = 10; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 10; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][10] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(9,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(9,1).
            {
                int dst_runtime = 9; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 9; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][11] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(8,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(8,1).
            {
                int dst_runtime = 8; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 8; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][12] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(7,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(7,1).
            {
                int dst_runtime = 7; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 7; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][13] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(6,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(6,1).
            {
                int dst_runtime = 6; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 6; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][14] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(5,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(5,1).
            {
                int dst_runtime = 5; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 5; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][15] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(4,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(4,1).
            {
                int dst_runtime = 4; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 4; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][16] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(3,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(3,1).
            {
                int dst_runtime = 3; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 3; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][17] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(2,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(2,1).
            {
                int dst_runtime = 2; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 2; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][18] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(1,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(1,1).
            {
                int dst_runtime = 1; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 1; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][19] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
        // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(0,1).
        {
            int src_runtime = 0; // Runtime index.
            int src_channel = 0; // Channel index.
            int src_bank = 0; // Bank index.
            // Iterate over range Philosophers.philosophers.start(0,1).
            {
                int dst_runtime = 0; // Runtime index.
                int dst_channel = 0; // Channel index.
                int dst_bank = 0; // Bank index.
                int range_count = 0;
                // Point to destination port Philosophers.philosophers.start's trigger struct.
                philosophers_runner_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][20] = &philosophers_philosophers_self[dst_runtime]->_lf__start;
            }
        }
    }
    
    // **** End of non-nested deferred initialize for Philosophers.runner
    // **** End of non-nested deferred initialize for Philosophers
    // Connect inputs and outputs for reactor Philosophers.
    // Connect inputs and outputs for reactor Philosophers.arbitrator.
    // Connect Philosophers.arbitrator.allFinished(0,1)->[Philosophers.runner.finish(0,1)] to port Philosophers.runner.finish(0,1)
    // Iterate over ranges Philosophers.arbitrator.allFinished(0,1)->[Philosophers.runner.finish(0,1)] and Philosophers.runner.finish(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.runner.finish(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            philosophers_runner_self[dst_runtime]->_lf_finish = (benchmarkrunner_finish_t*)&philosophers_arbitrator_self[src_runtime]->_lf_allFinished;
        }
    }
    // Connect Philosophers.arbitrator.eat(0,20)->[Philosophers.philosophers.eat(0,20)] to port Philosophers.philosophers.eat(0,20)
    // Iterate over ranges Philosophers.arbitrator.eat(0,20)->[Philosophers.philosophers.eat(0,20)] and Philosophers.philosophers.eat(0,20).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 20, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Philosophers.philosophers.eat(0,20).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                philosophers_philosophers_self[dst_runtime]->_lf_eat = (philosopher_eat_t*)&philosophers_arbitrator_self[src_runtime]->_lf_eat[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Philosophers.arbitrator.denied(0,20)->[Philosophers.philosophers.denied(0,20)] to port Philosophers.philosophers.denied(0,20)
    // Iterate over ranges Philosophers.arbitrator.denied(0,20)->[Philosophers.philosophers.denied(0,20)] and Philosophers.philosophers.denied(0,20).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 20, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Philosophers.philosophers.denied(0,20).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 1, 20 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                philosophers_philosophers_self[dst_runtime]->_lf_denied = (philosopher_denied_t*)&philosophers_arbitrator_self[src_runtime]->_lf_denied[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect inputs and outputs for reactor Philosophers.philosophers.
    // Connect Philosophers.philosophers.finished(0,20)->[Philosophers.arbitrator.finished(0,20)] to port Philosophers.arbitrator.finished(0,20)
    // Iterate over ranges Philosophers.philosophers.finished(0,20)->[Philosophers.arbitrator.finished(0,20)] and Philosophers.arbitrator.finished(0,20).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 1, 20 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Philosophers.arbitrator.finished(0,20).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 20, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                philosophers_arbitrator_self[dst_runtime]->_lf_finished[dst_channel] = (arbitrator_finished_t*)&philosophers_philosophers_self[src_runtime]->_lf_finished;
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)] to port Philosophers.arbitrator.hungry(0,20)
    // Iterate over ranges Philosophers.philosophers.hungry(0,20)->[Philosophers.arbitrator.hungry(0,20)] and Philosophers.arbitrator.hungry(0,20).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 1, 20 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Philosophers.arbitrator.hungry(0,20).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 20, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                philosophers_arbitrator_self[dst_runtime]->_lf_hungry[dst_channel] = (arbitrator_hungry_t*)&philosophers_philosophers_self[src_runtime]->_lf_hungry;
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Philosophers.philosophers.done(0,20)->[Philosophers.arbitrator.done(0,20)] to port Philosophers.arbitrator.done(0,20)
    // Iterate over ranges Philosophers.philosophers.done(0,20)->[Philosophers.arbitrator.done(0,20)] and Philosophers.arbitrator.done(0,20).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 1, 20 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Philosophers.arbitrator.done(0,20).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 20, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 20; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                int dst_channel = range_mr.digits[0]; // Channel index.
                int dst_bank = range_mr.digits[1]; // Bank index.
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                int src_channel = src_range_mr.digits[0]; // Channel index.
                int src_bank = src_range_mr.digits[1]; // Bank index.
                philosophers_arbitrator_self[dst_runtime]->_lf_done[dst_channel] = (arbitrator_done_t*)&philosophers_philosophers_self[src_runtime]->_lf_done;
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 20) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect inputs and outputs for reactor Philosophers.runner.
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.arbitrator.start(0,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.arbitrator.start(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.arbitrator.start(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            philosophers_arbitrator_self[dst_runtime]->_lf_start = (arbitrator_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(19,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(19,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(19,1).
        {
            int dst_runtime = 19; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 19; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(18,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(18,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(18,1).
        {
            int dst_runtime = 18; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 18; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(17,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(17,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(17,1).
        {
            int dst_runtime = 17; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 17; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(16,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(16,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(16,1).
        {
            int dst_runtime = 16; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 16; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(15,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(15,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(15,1).
        {
            int dst_runtime = 15; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 15; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(14,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(14,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(14,1).
        {
            int dst_runtime = 14; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 14; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(13,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(13,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(13,1).
        {
            int dst_runtime = 13; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 13; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(12,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(12,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(12,1).
        {
            int dst_runtime = 12; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 12; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(11,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(11,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(11,1).
        {
            int dst_runtime = 11; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 11; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(10,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(10,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(10,1).
        {
            int dst_runtime = 10; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 10; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(9,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(9,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(9,1).
        {
            int dst_runtime = 9; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 9; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(8,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(8,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(8,1).
        {
            int dst_runtime = 8; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 8; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(7,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(7,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(7,1).
        {
            int dst_runtime = 7; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 7; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(6,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(6,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(6,1).
        {
            int dst_runtime = 6; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 6; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(5,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(5,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(5,1).
        {
            int dst_runtime = 5; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 5; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(4,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(4,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(4,1).
        {
            int dst_runtime = 4; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 4; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(3,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(3,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(3,1).
        {
            int dst_runtime = 3; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 3; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(2,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(2,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(2,1).
        {
            int dst_runtime = 2; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 2; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(1,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(1,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(1,1).
        {
            int dst_runtime = 1; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 1; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    // Connect Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] to port Philosophers.philosophers.start(0,1)
    // Iterate over ranges Philosophers.runner.start(0,1)->[Philosophers.arbitrator.start(0,1), Philosophers.philosophers.start(19,1), Philosophers.philosophers.start(18,1), Philosophers.philosophers.start(17,1), Philosophers.philosophers.start(16,1), Philosophers.philosophers.start(15,1), Philosophers.philosophers.start(14,1), Philosophers.philosophers.start(13,1), Philosophers.philosophers.start(12,1), Philosophers.philosophers.start(11,1), Philosophers.philosophers.start(10,1), Philosophers.philosophers.start(9,1), Philosophers.philosophers.start(8,1), Philosophers.philosophers.start(7,1), Philosophers.philosophers.start(6,1), Philosophers.philosophers.start(5,1), Philosophers.philosophers.start(4,1), Philosophers.philosophers.start(3,1), Philosophers.philosophers.start(2,1), Philosophers.philosophers.start(1,1), Philosophers.philosophers.start(0,1)] and Philosophers.philosophers.start(0,1).
    {
        int src_runtime = 0; // Runtime index.
        int src_channel = 0; // Channel index.
        int src_bank = 0; // Bank index.
        // Iterate over range Philosophers.philosophers.start(0,1).
        {
            int dst_runtime = 0; // Runtime index.
            int dst_channel = 0; // Channel index.
            int dst_bank = 0; // Bank index.
            int range_count = 0;
            philosophers_philosophers_self[dst_runtime]->_lf_start = (philosopher_start_t*)&philosophers_runner_self[src_runtime]->_lf_start;
        }
    }
    {
        {
            // Add action Philosophers.arbitrator.send_replies to array of is_present fields.
            _lf_is_present_fields[0] 
                    = &philosophers_arbitrator_self[0]->_lf_send_replies.is_present;
        }
    }
    // Reactor is a bank. Iterate over bank members.
    for (int philosophers_philosophers_i = 0; philosophers_philosophers_i < 20; philosophers_philosophers_i++) {
    }
    {
        {
            // Add action Philosophers.runner.nextIteration to array of is_present fields.
            _lf_is_present_fields[1] 
                    = &philosophers_runner_self[0]->_lf_nextIteration.is_present;
        }
        {
            // Add action Philosophers.runner.done to array of is_present fields.
            _lf_is_present_fields[2] 
                    = &philosophers_runner_self[0]->_lf_done.is_present;
        }
    }
    {
        int count = 0;
        {
            // Add port Philosophers.arbitrator.allFinished to array of is_present fields.
            _lf_is_present_fields[3 + count] = &philosophers_arbitrator_self[0]->_lf_allFinished.is_present;
            count++;
            // Add port Philosophers.arbitrator.eat to array of is_present fields.
            // Port Philosophers.arbitrator.eat is a multiport. Iterate over its channels.
            for (int philosophers_arbitrator_eat_c = 0; philosophers_arbitrator_eat_c < 20; philosophers_arbitrator_eat_c++) {
                _lf_is_present_fields[3 + count] = &philosophers_arbitrator_self[0]->_lf_eat[philosophers_arbitrator_eat_c].is_present;
                count++;
            }
            // Add port Philosophers.arbitrator.denied to array of is_present fields.
            // Port Philosophers.arbitrator.denied is a multiport. Iterate over its channels.
            for (int philosophers_arbitrator_denied_c = 0; philosophers_arbitrator_denied_c < 20; philosophers_arbitrator_denied_c++) {
                _lf_is_present_fields[3 + count] = &philosophers_arbitrator_self[0]->_lf_denied[philosophers_arbitrator_denied_c].is_present;
                count++;
            }
        }
    }
    {
        int count = 0;
        // Reactor is a bank. Iterate over bank members.
        for (int philosophers_philosophers_i = 0; philosophers_philosophers_i < 20; philosophers_philosophers_i++) {
            // Add port Philosophers.philosophers.finished to array of is_present fields.
            _lf_is_present_fields[44 + count] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_finished.is_present;
            count++;
            // Add port Philosophers.philosophers.hungry to array of is_present fields.
            _lf_is_present_fields[44 + count] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_hungry.is_present;
            count++;
            // Add port Philosophers.philosophers.done to array of is_present fields.
            _lf_is_present_fields[44 + count] = &philosophers_philosophers_self[philosophers_philosophers_i]->_lf_done.is_present;
            count++;
        }
    }
    {
        int count = 0;
        {
            // Add port Philosophers.runner.start to array of is_present fields.
            _lf_is_present_fields[104 + count] = &philosophers_runner_self[0]->_lf_start.is_present;
            count++;
        }
    }
    
    // Set reaction priorities for ReactorInstance Philosophers
    {
        
        // Set reaction priorities for ReactorInstance Philosophers.arbitrator
        {
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_0.index = 0x7fffffffffff0000LL;
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_1.index = 0x7fffffffffff0002LL;
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 3 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_2.index = 0x7fffffffffff0003LL;
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_3.chain_id = 1;
            // index is the OR of level 5 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_3.index = 0x7fffffffffff0005LL;
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_4.chain_id = 1;
            // index is the OR of level 6 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_4.index = 0x7fffffffffff0006LL;
            //levels.size() == 1
            philosophers_arbitrator_self[0]->_lf__reaction_5.chain_id = 1;
            // index is the OR of level 7 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_arbitrator_self[0]->_lf__reaction_5.index = 0x7fffffffffff0007LL;
        }
        
        
        // Set reaction priorities for ReactorInstance Philosophers.philosophers
        // Reactor is a bank. Iterate over bank members.
        for (int philosophers_philosophers_i = 0; philosophers_philosophers_i < 20; philosophers_philosophers_i++) {
            //levels.size() == 1
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 2 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_0.index = 0x7fffffffffff0002LL;
            //levels.size() == 1
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 4 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_1.index = 0x7fffffffffff0004LL;
            //levels.size() == 1
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 5 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_philosophers_self[philosophers_philosophers_i]->_lf__reaction_2.index = 0x7fffffffffff0005LL;
        }
        
        
        // Set reaction priorities for ReactorInstance Philosophers.runner
        {
            //levels.size() == 1
            philosophers_runner_self[0]->_lf__reaction_0.chain_id = 1;
            // index is the OR of level 0 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_runner_self[0]->_lf__reaction_0.index = 0x7fffffffffff0000LL;
            //levels.size() == 1
            philosophers_runner_self[0]->_lf__reaction_1.chain_id = 1;
            // index is the OR of level 1 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_runner_self[0]->_lf__reaction_1.index = 0x7fffffffffff0001LL;
            //levels.size() == 1
            philosophers_runner_self[0]->_lf__reaction_2.chain_id = 1;
            // index is the OR of level 8 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_runner_self[0]->_lf__reaction_2.index = 0x7fffffffffff0008LL;
            //levels.size() == 1
            philosophers_runner_self[0]->_lf__reaction_3.chain_id = 1;
            // index is the OR of level 9 and 
            // deadline 140737488355327 shifted left 16 bits.
            philosophers_runner_self[0]->_lf__reaction_3.index = 0x7fffffffffff0009LL;
        }
        
    }
    
    
}
void _lf_trigger_startup_reactions() {
    for (int i = 0; i < _lf_startup_reactions_size; i++) {
        if (_lf_startup_reactions[i] != NULL) {
            #ifdef MODAL_REACTORS
            if (!_lf_mode_is_active(_lf_startup_reactions[i]->mode)) {
                // Mode is not active. Remember to trigger startup when the mode
                // becomes active.
                _lf_startup_reactions[i]->mode->should_trigger_startup = true;
                continue;
            }
            #endif
            _lf_trigger_reaction(_lf_startup_reactions[i], -1);
        }
    }
}
void _lf_initialize_timers() {

}
void logical_tag_complete(tag_t tag_to_send) {

}
bool _lf_trigger_shutdown_reactions() {

    // Return true if there are shutdown reactions.
    return (_lf_shutdown_reactions_size > 0);
}
void terminate_execution() {}
